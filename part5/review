*) Functions typically decompose their arguments into their immediate structural components and then process those components. If one of these immediate components belongs to the same class of data as the input, the function is structurally recursive.

*) There is also generative recursion. The inputs of an algorithm represent a problem. An algorithm tends to re-arrange a problem into a set of several problems, solve those, and combine their solutions into one overall solution. Often some of these newly generated problems are the same kind of problem as the given one. In these cases, the algorithm is recursive but its recursion uses newly generated data not immediate parts of the input data.

*) The choice of a data representation for a problem affects our thinking about the computational process. Be prepared to backtrack and to explore different data representations.

*) The goal of testing is to discover and eliminate bugs.

*) Generative recursion is not always superior to structural recursion. It is difficult to understand, requires some deep insight and sometimes slower (quick-sort vs. insertion-sort for small arrays). Experience shows that most functions employ structural design. When we encounter a situation that could use either structural or generative recursion, start with a structural version.

*) When creating a function that applies generative recursion, in the purpose statement we should articulate not only WHAT the function does, but also HOW it does it (just a few words). Example:
   ; Number -> Image
   ; generative creates Sierpinski Δ of size side by generating
   ; one for (/ side 2) and placing one copy above two copies

*) Parsing is so complex and so central to the creation of full-fledged software applications, that most undergraduate curricula come with at least one course on parsing.

*) ISL+ treats numbers like 2.9999 as exact rational numbers and computation with them can take a lot of time. Use #i2.9999 if needed.

*) While we have dubbed it generative recursion, most computer scientists refer to these functions as algorithms.

*) Unlike structurally designed functions, algorithms may not terminate for some inputs. You should present some argument that the program will terminate and warn the readers of your code of "bad" input.

*) For truly clever algorithms, software companies employ highly paid specialists, domain experts, and mathematicians. Programmers in general don't have to devise algorithms.

*) When programs grow large, data abstraction becomes a critical tool for the construction of a program’s components.

*) 
