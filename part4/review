*) In this part we jump from self-referential data definitions to collections of data definitions with mutual references plus self-references.

*) For intertwined data definitions, create one template per data definition. Create them in parallel. Make sure they refer to each other in the same way the data definitions do.

*) You must design as many functions in parallel as there are data definitions. Each function specializes for one of the data definitions; all remaining arguments remain the same.

*) Check for all self references and cross references. Look at the arrows in data definitions. For each arrow in the data definitions, include an arrow in the templates. Now replace the arrows with actual function calls.

*) Each arrow leads to a function call. It is called symmetry.

*) Iterative refinement comes form science. A scientist creates a model to represent some part of the world. Then he tests it and refines until the discrepancies are small enough.

*) Complicated situations call for a refinement process to get to a sufficient data representation combined with the proper functions. The process starts with the essential pieces of information and adds others as needed.

*) XML is really a family of languages. People define dialects for specific channels of communication. For example, XHTML is the language for sending web content in XML format.

*) You should design a separate function whenever you encounter a complex form of data, such as this list of items.

*) You can visualize an S-expression as a tree (one or more branches) where each leaf is an Atom (Symbol, Number, Stirng) and each node is a list containing its children in order. Example:
   '(10 (20 'apple ("one" 'two)) "apple")

   An X-expression is a subset of S-expressions. It is a list, where the first element is always a symbol, then goes an optional list of attributes, then goes zero ore more S-expressions. Examples:
   '(machine)
   '(machine ((cores "2") (os "Linux")))
   '(machine ((cores "2") (os "Linux")) (core) (core))

   XEnum, XItem and XWord form a subset of X-epressions and represent unordered lists. Lists can be nested. Example:
   '(ul
     (li (word ((text "one"))))
     (li (word ((text "two"))))
     (li (ul
          (li (word ((text "1")))))))

*) Programmers devise simple, special-purpose languages for administrators to configure the system. These special languages are also known as a domain-specific languages (DSL).

*) A DSL can be a sublanguage of XML. Here is a possible configuration of a finite state machine:
   <machine initial="white">
     <action state="white" next="black" />
     <action state="black" next="white" />
   </machine>

*) It is better to design a function in a systematic manner and than simplify it, than creating a simplified version right away. Because in the first case there is a smaller chance for a bug.

*) When a function consumes two complex data types, create a table that matches all cases for the first type with all cases for the second. For every cell in the table create a functional example and a cond clause. The key idea is to translate the data definitions into a table that shows all feasible and interesting combinations.



   

