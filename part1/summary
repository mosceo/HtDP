;===============================================================================
; Part 1. Main points.
;===============================================================================

*) In general, when a problem refers to distinct tasks of computation, a program should consist of one function per task and a main function that puts it all together. Here is a simple slogan: Define one function per task.

*) For every constant mentioned in a problem statement, introduce one constant definition.

*) A batch program consumes all of its inputs at once (maybe from files) and computes its result. An interactive program consumes some of its inputs, computes, produces some output, consumes more input, and so on.

*) A good program comes with a short write-up that explains what it does, what inputs it expects, and what it produces. Ideally, it also comes with some assurance that it actually works.

*) Sometimes to write a program you might need some knowledge from other fields (e.g., physics or biology). It is called domain knowledge.

-) Programs work with informtion. For a program to process information, it must turn it into some form of data in the programming language; then it processes the data; and once it is finished, it turns the resulting data into information again.

-) Мы должны решить как представлять информацию в виде данных. Мы пишем data definition в виде комментариев. Они описывают класс данных, а также дают примеры как создавать элементы этого класс.

Примеры:

; A PositiveNumber is a Number greater or equal to 0. 

; A Temperature is a Number. 
; interpretation represents Celsius degrees

; An AnimationState is a Number.
; interpretation the number of clock ticks 
; since the animation started

-) Рецепт проектирования функции состоит из шести шагов. Вот пример завершённой функции:
; Number -> Number                                < signature
; computes the area of a square with side len     < purpose statement
; given: 2, expect: 4                             < examples
; given: 7, expect: 49
(define (area-of-square len)                      < function definition (body)
  (sqr len))

*) Top-down approach to design says that we first design top-level functions, than lower-level functions, than more-lower-level primitives and so on. We can implement a top-level function in terms of lower-level functions that don't yet exist. We pretend that they exist and put them on our *wish-list* to implement them later.

*) MVC makes it easier to develop the application. We can separete working on data (model) from working on its representation (view). When we decide how data changes, we don't have to think how its rendering on the screen changes.


-) Designing World Programs.
1. For all those properties of the world that remain the same over time and are needed to render it as an Image, introduce constants. 
2. Those properties that change over time—in reaction to clock ticks, key strokes, or mouse actions—give rise to the current state of the world. Your task is to develop a data representation for all possible states of the world.
3. Once you have a data representation for the state of the world, you need to design a number of functions so that you can form a valid big-bang expression.
4.

-) Enumerations

; A TrafficLight is one of the following Strings:
; – "red"
; – "green"
; – "yellow"
; interpretation the three strings represent the three 
; possible states that a traffic light may assume 

; WorldState KeyEvent -> ...
(define (handle-key-events w ke)
  (cond
    [(= (string-length ke) 1) ...]
    [(string=? "left" ke) ...]
    [(string=? "right" ke) ...]
    [(string=? "up" ke) ...]
    [(string=? "down" ke) ...]
    ...))

-) An interval is a description of a class of numbers via boundaries.

; A Price falls into one of three intervals: 
; — 0 through 1000
; — 1000 through 10000
; — 10000 and above.
; interpretation the price of an item  

; Price -> Number
; compute sales tax
(define (sales-tax p)
  (cond
    [(and (<= 0 p) (< p 1000)) ...]
    [(and (<= 1000 p) (< p 10000)) ...]
    [(>= p 10000) ...]))

-) itemizations, which generalize intervals and enumerations. They allow the combination of any already-defined data classes with each other and with individual pieces of data.

; A LRCD (for launching rocket count down) is one of:
; – "resting"
; – a Number between -3 and -1
; – a NonnegativeNumber 
; interpretation a grounded rocket, in count-down mode,
; a number denotes the number of pixels between the
; top of the canvas and the rocket (its height)

-) Проектирование функции зависит от типа данных. For functional examples, however, it is imperative that you pick at least one example from each sub-class in the data definition. 

-) Структура собирает несколько эементов в единое целое. Создаются так (define-struct posn [x y]). Создаётся ряд функция: конструктор, селекторы, предикат.

(define-struct person [name hair eyes phone])
(define-struct CD [artist title price])

-) Определение стуктурных типов данных

(define-struct vel [deltax deltay])
; A Vel is a structure: 
;   (make-vel Number Number)
; interpretation (make-vel dx dy) means a velocity of 
; dx pixels [per tick] along the horizontal and
; dy pixels [per tick] along the vertical direction

(define (ufo-move-1 u)
  (... (ufo-loc u) ... (ufo-vel u) ...))


*) One thing to keep in mind is that data definitions may refer to other data definitions.  If a function deals with nested structures, develop one function per level of nesting. 

*) It is better if your program has a few pivotal constants and everything else follow from them. For example, you define the size of a ball and the sizes of other objects are computed from it. 

*) Make examples for data definitions like you do for functions. Examples help to understand.

*) When we design an application, we make design choices. In future they may turn out to be bad design choices. We might realize that If we had chosen other data structures the program would be simpler. We can't learn how to make good choices, it only comes with practice.

making design choices. Проектирую определения данных мы делаем выбор. Выбор может быть плохой, программа будет длиннее и сложнее. Как делать правильный выбор? Это приходит с практикой.

*) Don't reinvent the wheel. Your language probably comes with a rich library and you have to know it well. Functions from the library are well-written and well-tested.

